<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>player_set</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Balkman Darwin Jr

qspin = 1;
nospin = 1;
sq = 16;
z = 0;
x2 = x + sq;
z2 = z + sq;
y2 = y + sq;

ort = 2;
aort2 = 270;
ggravity = 0;

var cH = 191;
var cS = 84;
var cV = 76;
skin = background_create_color(16,16,
                               make_color_hsv(round(cH*255/360),
                                              round(cS*255/100),
                                              round(cV*255/100)));

//Shaders
anim = scr_load_animation("./char_cube.bao",true);
anim_l[0] = room_speed*1;
anim_s[0] = -1;
shader_ambientColor = shader_get_uniform(sh_blend,"uAmbientColor");
shader_lightDirection = shader_get_uniform(sh_blend,"uLightingDirection");
shader_lightDirectionalColor = shader_get_uniform(sh_blend,"uDirectionalColor");
shader_worldMatTranspInv = shader_get_uniform(sh_blend,"uMatWorldTransInv");

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///PLAYER

//Control scheme
if sculptor.ctrl_opt&amp;1
{   if (abs(point_distance(0,0,gamepad_axis_value(0,gp_axislh),
            gamepad_axis_value(0,gp_axislv))) &gt; 0.2)
    {   xv = gamepad_axis_value(0,gp_axislh) * 3;
        zv = gamepad_axis_value(0,gp_axislv) * 3;
    }
    else
    {   xv = 0;
        zv = 0;
    }
    gp_l = gamepad_button_check_pressed(0,gp_shoulderl);
    gp_r = gamepad_button_check_pressed(0,gp_shoulderr);
}
else
{   xv = (keyboard_check(ord('D'))-keyboard_check(ord('A'))) * 3;
    zv = (keyboard_check(ord('S'))-keyboard_check(ord('W'))) * 3;
    gp_l = keyboard_check_pressed(ord('Q'));
    gp_r = keyboard_check_pressed(ord('E'));
}
xgrav = (-zv*dcos(-camera.mouse_direction+270+90*(qspin==3 or qspin==6)-90*(qspin==2))
         +xv*dcos(-camera.mouse_direction+90*(qspin==3 or qspin==6)-90*(qspin==2))) * sign(camera.cc);
zgrav = (-zv*dsin(-camera.mouse_direction+270+90*(qspin==3 or qspin==6)-90*(qspin==2))
         +xv*dsin(-camera.mouse_direction+90*(qspin==3 or qspin==6)-90*(qspin==2))) * sign(camera.cc);
ygrav = 3 + ggravity;

//Axel spin to new top (1:top|2:north|3:west|4:east|5:south|6:bottom)
qspin2 = qspin;
if !nospin switch qspin
{   case 1:     if gp_l switch ort
                {   case 2: qspin = 3;
                            camera.mouse_direction += 90;
                            break;
                    case 3: qspin = 5; break;
                    case 4: qspin = 2;
                            camera.mouse_direction -= 90;
                            break;
                    case 5: qspin = 4; break;
                }
                else if gp_r switch ort
                {   case 2: qspin = 4; break;
                    case 3: qspin = 2;
                            camera.mouse_direction -= 90;
                            break;
                    case 4: qspin = 5; break;
                    case 5: qspin = 3;
                            camera.mouse_direction += 90;
                            break;
                }
                break;
                
    case 2:     if gp_l switch ort
                {   case 2: qspin = 3;
                            camera.mouse_direction -= 90;
                            break;
                    case 3: qspin = 1;
                            camera.mouse_direction += 90;
                            break;
                    case 4: qspin = 6; break;
                    case 5: qspin = 4; break;
                }
                else if gp_r switch ort
                {   case 2: qspin = 4; break;
                    case 3: qspin = 6; break;
                    case 4: qspin = 1;
                            camera.mouse_direction += 90;
                            break;
                    case 5: qspin = 3;
                            camera.mouse_direction -= 90;
                            break;
                }
                break;
                
    case 3:     if gp_l switch ort
                {   case 2: qspin = 6; break;
                    case 3: qspin = 5; break;
                    case 4: qspin = 2;
                            camera.mouse_direction += 90;
                            break;
                    case 5: qspin = 1;
                            camera.mouse_direction -= 90;
                            break;
                }
                else if gp_r switch ort
                {   case 2: qspin = 1;
                            camera.mouse_direction -= 90;
                            break;
                    case 3: qspin = 2;
                            camera.mouse_direction += 90;
                            break;
                    case 4: qspin = 5; break;
                    case 5: qspin = 6; break;
                }
                break;
                
    case 4:     if gp_l switch ort
                {   case 2: qspin = 1; break;
                    case 3: qspin = 5;
                            camera.mouse_direction -= 90;
                            break;
                    case 4: qspin = 2; break;
                    case 5: qspin = 6;
                            camera.mouse_direction += 90;
                            break;
                }
                else if gp_r switch ort
                {   case 2: qspin = 6;
                            camera.mouse_direction += 90;
                            break;
                    case 3: qspin = 2; break;
                    case 4: qspin = 5;
                            camera.mouse_direction -= 90;
                            break;
                    case 5: qspin = 1; break;
                }
                break;
                
    case 5:     if gp_l switch ort
                {   case 2: qspin = 3; break;
                    case 3: qspin = 6;
                            camera.mouse_direction -= 90;
                            break;
                    case 4: qspin = 1; break;
                    case 5: qspin = 4;
                            camera.mouse_direction += 90;
                            break;
                }
                else if gp_r switch ort
                {   case 2: qspin = 4;
                            camera.mouse_direction += 90;
                            break;
                    case 3: qspin = 1; break;
                    case 4: qspin = 6;
                            camera.mouse_direction -= 90;
                            break;
                    case 5: qspin = 3; break;
                }
                break;
                
    case 6:     if gp_l switch ort
                {   case 2: qspin = 4;
                            camera.mouse_direction -= 90;
                            break;
                    case 4: qspin = 5;
                            camera.mouse_direction += 90;
                            break;
                    case 3: qspin = 2; break;
                    case 5: qspin = 3; break;
                }
                else if gp_r switch ort
                {   case 2: qspin = 3; break;
                    case 4: qspin = 2; break;
                    case 3: qspin = 5;
                            camera.mouse_direction += 90;
                            break;
                    case 5: qspin = 4;
                            camera.mouse_direction -= 90;
                            break;
                }
                break;
}

PHYSICS(1);
if ggravity &gt;= 14
    room_restart();

//Next room
if is_array(wchk) and (gnew==0) and (gold==0)
and (x&gt;=wchk[0,0]) and (x2&lt;=wchk[0,1])
and (z&gt;=wchk[1,0]) and (z2&lt;=wchk[1,1])
and (y&gt;=wchk[2,0]) and (y2&lt;=wchk[2,1])
{   if wchk[3].rm == "r0"
    {   show_message("You finished the test build, why not explore some more.");
        game_end();
    }
    else
    {   ini_open("starter.ini");
        ini_write_real("spawn",'x',wchk[3].nx);
        ini_write_real("spawn",'z',wchk[3].nz);
        ini_write_real("spawn",'y',wchk[3].ny);
        ini_write_real("spawn",'q',qspin);
        ini_write_real("camera",'m',camera.mouse_direction);
        ini_write_real("camera",'z',camera.zview);
        ini_write_real("camera",'d',camera.dist);
        room_goto(asset_get_index(wchk[3].rm));
        ini_close();
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///SELF

texture_set_repeat(true);
shader_set(sh_blend);
shader_set_uniform_f(shader_ambientColor,0.3,0.3,0.3);
shader_set_uniform_f(shader_lightDirection,0.5,-0.5,0.5);
shader_set_uniform_f(shader_lightDirectionalColor,1,1,1);

d3d_transform_set_identity();
d3d_transform_add_scaling(1.5,1.5,1.5);
switch qspin
{   case 1: d3d_transform_add_rotation_x(270);
            //d3d_transform_add_rotation_z(180*(qspin==6)+90*(qspin==3)+270*(qspin==4));
            if (aort!=360 and aort!=180)
                aort2 = -aort;
            d3d_transform_add_rotation_y(aort2);
            break;
    case 2: d3d_transform_add_rotation_x(180);
            ////d3d_transform_add_rotation_z(180*(qspin==6)+90*(qspin==3)+270*(qspin==4));
            if (aort!=360 and aort!=180)
                aort2 = -aort;
            d3d_transform_add_rotation_z(aort2);
            break;
    case 3: d3d_transform_add_rotation_y(90);
            //d3d_transform_add_rotation_z(0);
            if (aort!=360 and aort!=180)
                aort2 = -90-aort;
            d3d_transform_add_rotation_x(aort2);
            break;
    case 4: d3d_transform_add_rotation_y(270);
            //d3d_transform_add_rotation_z(0);
            if (aort!=360 and aort!=180)
                aort2 = -90+aort;
            d3d_transform_add_rotation_x(aort2);
            break;
    case 5: d3d_transform_add_rotation_x(0);
            ////d3d_transform_add_rotation_z(180*(qspin==6)+90*(qspin==3)+270*(qspin==4));
            if (aort!=360 and aort!=180)
                aort2 = aort;
            d3d_transform_add_rotation_z(aort2);
            break;
    case 6: d3d_transform_add_rotation_x(270);
            d3d_transform_add_rotation_z(180);
            if (aort!=360 and aort!=180)
                aort2 = aort;
            d3d_transform_add_rotation_y(aort2);
            break;
}
d3d_transform_add_translation(x+8,y+7,z+8);

var worldMat = scr_TranspoInverse(matrix_get(matrix_world));
shader_set_uniform_f_array(shader_worldMatTranspInv,worldMat);
scr_draw_animation_frame(anim,anim_s[0],anim_l[0],background_get_texture(skin));
d3d_transform_set_identity();
shader_reset();
//d3d_draw_cone(x + sq/2 + 200,y + sq/2 + 200,z+350,
  //            x + sq/2 - 200,y + sq/2 - 200,z-300,2,0,0,false,12);
d3d_draw_ellipsoid(cam_x+4,cam_y+4,cam_z+4,cam_x-4,cam_y-4,cam_z-4,2,0,0,4);
/*if spbb
    d3d_draw_block(spx,spy,spz,spx2,spy2,spz2,test,0,0);
/*switch qspin
{   case 1: d3d_draw_ellipsoid(x,y2,z,x2,y2,z2,2,0,0,8);
            break;
    case 2: d3d_draw_ellipsoid(x,y,z2,x2,y2,z2,2,0,0,8);
            break;
    case 3: d3d_draw_ellipsoid(x2,y,z,x2,y2,z2,2,0,0,8);
            break;
    case 4: d3d_draw_ellipsoid(x,y,z,x,y2,z2,2,0,0,8);
            break;
    case 5: d3d_draw_ellipsoid(x,y,z,x2,y2,z,2,0,0,8);
            break;
    case 6: d3d_draw_ellipsoid(x,y,z,x2,y,z2,2,0,0,8);
            break;
}*/

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
